---
layout: post
title: Comparing Nullable(of T) Values
date: '2009-01-12T20:13:00.000-06:00'
updated: "2019-03-07 19:46:00"
permalink: "/2009/01/comparing-nullableof-t-values.html"
author: Stephen Wrighton
tags:
- ".NET"
- programming
- VB.Net
- Coding
modified_time: '2009-01-12T20:13:00.428-06:00'
thumbnail: http://1.bp.blogspot.com/_0dC8-RtLatg/SWu44L1v10I/AAAAAAAAAok/HHLSj9rBmsg/s72-c/code_01122009.png
blogger_id: tag:blogger.com,1999:blog-947968907697915479.post-6925371181564433917
blogger_orig_url: https://programmer.wrighton.org/2009/01/comparing-nullableof-t-values.html
---

Okay, I spent a good half hour earlier today slamming my head against the wall, trying to figure something out.  Why my checkboxes in my tri-state tree were not getting set to the correct state based on user input.<br /><br />What this is, is each checkbox on the tree has three possible checked states: true, false and indeterminate.<br /><br />I had some rules going into this:<br /><ol><li>A checkbox's state is the summation of its children's state (if all children are TRUE, then it is TRUE).</li><li>A checkbox is indeterminate when any of its children are not in the same state as itself.</li><li>If a Checkbox's Parent is set to TRUE or FALSE, then the Checkbox shall be set to the same<br /></li></ol>Pretty straightforward if you ask me, and the state was being controlled by a nullable boolean (which is declared DIM _isChecked as Nullable(of Boolean) in VB or Boolean? _isChecked in C#).<br /><br />Now, I'm using VB.Net for this, and when I only had a single set of children until you got to the lowest level, it all worked perfectly. I was happy and smiling. Well, today I shoved in extra children for every level that could have them, and got something... new for my troubles: only the first child was affecting the parent nodes, thus breaking rule 2, while modifying UP the tree.<br /><br />Modifying down, still worked like a charm.<br /><br />So, I'm off grumbling, and toss in a Breakpoint on the comparison operation. I mean, I see in the code where this value is supposed to be changed, and so that proverbial key to the kingdom is where I need to be looking.<br /><br />I start up the application, get to the point in it where I use the tree, and uncheck something. the break point fires, and the promptly skips over the code, confused, I let it cycle back around as it verify's the parent's state.<br /><br />Once I'm at the checkpoint again, I look to see what the result of the comparison operation is.<br /><br />Only to discover, nothing.<br /><br />Which means that the comparison did not fire, because their is no equilavencies between the two opposing states.<br /><br />Frowning, I considered the implications of this, when suddenly I realized what was happening. A nullable boolean, has three possible values: True, False and NOTHING.  The problem exists because NOTHING cannot be processed through a comparison operation such as "=" or, as I was using, "<>."<br /><br />So, what was this poor programmer to do?<br /><br />What I had forgotten, was the nullable objects have a "HasValue" property which returns a boolean based on if the variable is NOTHING or not.<br /><br />Which means that, I had some fun coding to look forward to.  Let's look at this, I had two values to check, both of them Nullable(of Booleans), which means I have this potential set of values:<br /><table style="width: 311px; height: 522px;" border="1" cellpadding="2" cellspacing="2"><br /><caption> Possible States </caption><tbody><tr><td>Value 1</td><td>Value 2</td><td>What I need to do</td></tr><tr><td>N</td><td>N</td><td>Both Nullable Do Nothing </td></tr><tr><td>N</td><td>T</td><td>Different, Change</td></tr><tr><td>N</td><td>F</td><td>Different, Change</td></tr><tr><td>T</td><td>N</td><td>Different, Change</td></tr><tr><td>T</td><td>T</td><td>Both True, Do Nothing </td></tr><tr><td>T</td><td>F</td><td>Different, Change</td></tr><tr><td>F</td><td>N</td><td>Different, Change</td></tr><tr><td>F</td><td>T</td><td>Different, Change</td></tr><tr><td>F</td><td>F</td><td>Both False, Do Nothing </td></tr></tbody></table><br />Where F=False, T=True, and N=Nothing. Those are all the potential states that I had to check for. Luckily, I had a few shortcuts for my logic:<br /><ol><li>If they're both nothing, I don't have to do anything</li><li>If one is nothing and the other Has a value, I HAVE to change</li></ol>With those two logical operations in place (thanks to my handle state chart) I knew I only had to check for differences when both of my items had a value.  Which in turns means that I ended up with an IF statement, which reads like:<br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://1.bp.blogspot.com/_0dC8-RtLatg/SWu44L1v10I/AAAAAAAAAok/HHLSj9rBmsg/s1600-h/code_01122009.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer; width: 320px; height: 181px;" src="http://1.bp.blogspot.com/_0dC8-RtLatg/SWu44L1v10I/AAAAAAAAAok/HHLSj9rBmsg/s320/code_01122009.png" alt="" id="BLOGGER_PHOTO_ID_5290525462667188034" border="0" /></a><br />One of these days, Blogger will support Code formatting, and I just won't know what to do. But I digress.<br /><br />Now, if Microsoft had put a bit of FORETHOUGHT into their Nullable(of T) objects in VB.Net they would have provided inherent comparison operations between two instances of the Nullable(of T) objects. But that may be asking for a bit much I fear.