---
layout: post
title: The Amazing Disappearing RecordSet
date: '2007-02-22T15:24:00.000-06:00'
author: Stephen Wrighton
tags:
- programming
- Coding
- Web
- Testing
modified_time: '2007-02-22T15:51:26.615-06:00'
blogger_id: tag:blogger.com,1999:blog-947968907697915479.post-8597125128854659120
blogger_orig_url: https://programmer.wrighton.org/2007/02/amazing-disappearing-recordset.html
---

We have a client which uses a WBT Course Management System which they purchased. It is a classic ASP web application, whose standard database is Access and they have just recently introduced the ability to use SQL Server as a backend. Our task in this thing is hosting and fixing any issues which the company stumbles across while using it.<br /><br />Not that big of a deal, one would think.<br /><br />One would think.<br /><br />Frankly, I'm not certain how this piece of software managed to make it out of Integration Testing. My guess, the developers don't know what integration testing is, let alone system or qualification testing.<br /><br />Our client discovered an error, and asked us to find and fix it. So here we are, hunting through the code trying to figure out what is happening.  Ultimately we discover that the problem is an array is not being populated from the database. No big deal. So we look closer, and notice that the array is being redim'd using the variable <span style="font-weight: bold;">Num_of_Questions.  </span>Which makes sense. You want this array to be of a size of the number of questions you have.  But during population, you have the index being referenced via the RecordSet field <span style="font-weight: bold;">Perm_Question_Number</span>.<br /><br />Being a proponent of normalized databases, this through off warning bells in my head. For I assumed that it tied the question being asked to the answer.<br /><br />Boy was I wrong.<br /><br />I open up the database, and was greeted with a massive jumble of tables and fields. Consider the temporary table for holding user values:<br /><br /><span style="font-weight: bold;">Temp_User_Answers</span><br /><ul><li>User ID</li><li>Course_Number</li><li>Test_Number</li><li>Perm_Question_Number</li><li>Question</li><li>Answer A</li><li>Answer B</li><li>Answer C</li><li>Answer D</li><li>Answer E</li><li>Answer F</li><li>Answer G</li><li>Correct_Answer</li><li>Stud_Answer</li></ul>Yeah. It tied to the Test_Content table via the Perm_Question_Number which was a one-based index for that Test's questions rather than the table's ID field (which was not set as a primary key, despite being the auto-incrementing, identity inserted field).  And in case you're wondering, yes all of those answers and the question were repeated in that table as well.<br /><br />Banging my head on my desk by this time, we get in contact with the developers of the software to ask them what they were smoking/drinking/etc while designing this software. Or if they even did design it. Or why they would do such a thing to a poor database.<br /><br />Their response: "Ease of use."<br /><br />If only, one could be throttled over the long-distance communication tools.<br /><br />So, realizing that there was no help forthcoming from this crap-design as feature developers, we once more dug into the code trying to figure out why the values would disappear from the recordset.<br /><br />Ultimately, we discovered that it has something to do with populating that array directly from the recordset. What was in the code was:<br /><blockquote>studAnswers(rRS("Perm_Question_Num")) = rRS("Stud_Answer")<br />correctAnswers(rRS("Perm_Question_Num")) = rRS("Correct_Answer")<br /></blockquote>And for whatever reason, this just refused to work. The system despised that line of code and refused to use the recordset after it (i.e. studAnswer was populated, but correctAnswers wasn't and any use of the recordset after it just acted like it didn't happen).<br /><br />Well, having already discovered that I hate this code, and that it is riddled with flawed logic, shotty design, subpar commenting and no tabs, I figured why don't we just bandage it.<br /><br />So we changed the code to look like this:<blockquote>questionNumber = rRS("Perm_Question_Num")<br />studentAnswer = rRS("Stud_Answer")<br />rightAnswer = rRS("Correct_Answer")<br />studAnswer(questionNumber") = studentAnswer<br />correctAnswers("questionNumber") = rightAnswer<br /></blockquote>Lo, and behold, the page built successfully and properly.<br /><br />Not the best solution, and I still don't know why the recordset would just stop working, but the application is running - and for our purposes that's what is important here. Anyone else that has the misfortune of buying this software can figure it out on their own (or hire us to do it).<br /><br />So, with a bandage in place, I begin the process of removing the various Response.Write's which I had sprinkled throughout the page and add in a comment up at the top indicating that you know... a developer had done something here when I discovered the most perfect piece of code logic I have ever seen.<br /><br />The one and only bit of error handling I found on the page.<blockquote>If err.Number = 0 then<br />End If ' Check to see if there are no errors<br /></blockquote>Yes. You read that right. And yes, that was all there was to it. The developer, in his infinite coding goodness, took the time out to check the ADODB error object to see if it had no errors.  He asked the code, if everything was right.<br /><br />That echoing sound you hear, is probably me still smacking my head against the desk. The junior developer I was assisting in this maintenance issue is still chuckling over in his office. And we took the extra effort of going out and gathering the other developers and showing them this beautiful piece of logic.<br /><br />Why he would check for success is beyond me. Frankly, in those scenarios I'm more worried about when err.Number is not equal to 0 as that means there is a problem which I need to deal with. If there's no problem, then I don't even need to spend time checking to see if there's no problem.<br /><br />I'm flabbergasted at such coding. The entire thing gives all programmers a bad name.