---
layout: post
title: Nested Stored Procedures & Data results
date: '2007-03-12T16:09:00.000-05:00'
author: Stephen Wrighton
tags:
- programming
- Coding
- SQL Server
modified_time: '2007-03-12T16:30:55.902-05:00'
blogger_id: tag:blogger.com,1999:blog-947968907697915479.post-2495323120857097588
blogger_orig_url: https://programmer.wrighton.org/2007/03/nested-stored-procedures-data-results.html
---

For my project at work, I went about building the search capabilities today. The system has two main data types that can be searched for mutually exclusive of one another, and later iterations of the software may have other data types which can be searched for then. My solution was a Windows.Form which would display the search results and allow the user to enter a search term list (separated by a comma) and research. The search itself would be powered by a stored procedure hiding in SQL Server.<br /><br />No big deal right?<br /><br />Well it worked until I tried to parse the search terms list out. I knew I would have multiple stored procedures doing the heavy work of searching, so I only wanted to keep maintain the functionality to split the search term out into an array in a single place. So I stuck it into a stored procedure.<br /><br />Smart huh?<br /><br />One would think so. Unfortunately, SQL Server does not allow for the manipulation of data sets returned from Stored Procedures - and this includes that they do not allow me to stick that returned data set into a temporary table so I can walk it with a cursor to perform my searches.<br /><br />Annoying to say the least.<br /><br />So I turned to Google for a bit, and then realized that some of my co-workers had a similar problem in their project. So I came out of my den... err, my office and wandered across the hall to talk to the guy over there.<br /><br />He showed me the solution they're using, and I felt like smacking myself on the forehead.<br /><br />It was that little used option for manipulating data in SQL Server in composite chunks. You know, FUNCTIONS.<br /><br />Apparently, the table dataset that a SQL Server function which returns can be manipulated by a calling Stored Procedure or function.<br /><br />Since, I got the base Stored Procedure for splitting a search string into tabular format from the web, I figured I would post how I changed that to a function on the web.<br /><blockquote><span style="font-size:85%;"><span style="color: rgb(0, 153, 0);">/********************************************************************************</span><br /><span style="color: rgb(0, 153, 0);">* Procedure Name: ParseArray                                                *<br /></span><span style="color: rgb(0, 153, 0);">* Author:    graz@sqlteam.com                                                    *<br /></span><span style="color: rgb(0, 153, 0);">* Purpose:  Takes two inputs, a csv style string                                *<br /></span><span style="color: rgb(0, 153, 0);">*               AND the seperator.  Returns a table of all the values           *<br /></span><span style="color: rgb(0, 153, 0);">*               in the CSV style string                                         *<br /></span><span style="color: rgb(0, 153, 0);">*                                                                               *<br /></span><span style="color: rgb(0, 153, 0);">* History:                                                                      *<br /></span><span style="color: rgb(0, 153, 0);">*     03/07/2007 Modified to be a Function<br /></span><span style="color: rgb(0, 153, 0);">*                                                                               *<br /></span><span style="color: rgb(0, 153, 0);">********************************************************************************/</span><br /><br /><span style="color: rgb(51, 51, 255);">CREATE FUNCTION</span> dbo.ParseArray<br />  (<br />     @Array <span style="color: rgb(51, 51, 255);">VARCHAR</span>(1000),<br />     @Separator <span style="color: rgb(51, 51, 255);">CHAR</span>(1)<br />  )<br /><span style="color: rgb(51, 51, 255);">RETURNS </span>@Return <span style="color: rgb(51, 51, 255);">TABLE </span>(Word VARCHAR(1000) )<br /><span style="color: rgb(51, 51, 255);">AS  </span><br /><span style="color: rgb(51, 51, 255);">BEGIN </span><span style="color: rgb(0, 153, 0);">-- FUNCTION</span><br /><br />      <span style="color: rgb(0, 153, 0);">-- @Array is the array we wish to parse</span><br /><span style="color: rgb(0, 102, 0);"><span style="color: rgb(0, 153, 0);">      -- @Separator is the separator character such as a comma<br /></span></span><span style="color: rgb(0, 102, 0);"> </span>     <span style="color: rgb(51, 51, 255);">DECLARE </span>@Separator_Position <span style="color: rgb(51, 51, 255);">INT</span>; <span style="color: rgb(0, 153, 0);">-- This is used to locate each separator character<br /></span>      <span style="color: rgb(51, 51, 255);">DECLARE </span>@Array_Value <span style="color: rgb(51, 51, 255);">VARCHAR</span>(1000); <span style="color: rgb(0, 153, 0);">-- this holds each array value as it is returned<br /></span>      <span style="color: rgb(51, 51, 255);">DECLARE </span>@Temp <span style="color: rgb(51, 51, 255);">INT</span>;<br /><br />      <span style="color: rgb(0, 153, 0);">-- For my loop to work I need an extra separator at the end.  I always look to the<br /></span><span style="color: rgb(0, 153, 0);">      -- left of the separator character for each array value<br /></span><span style="color: rgb(0, 153, 0);">      </span><span style="color: rgb(51, 51, 255);">SET </span>@Array = @Array + @Separator<br /><br />   <span style="color: rgb(0, 153, 0);">   -- Loop through the string searching for separtor characters<br /></span><span style="color: rgb(0, 153, 0);">   </span>   <span style="color: rgb(51, 51, 255);">WHILE PATINDEX</span>('%' + @Separator + '%' , @Array) <> 0<br />            <span style="color: rgb(51, 51, 255);">BEGIN</span> <span style="color: rgb(0, 153, 0);">-- While PATINEDEX('%' + @Separator + '%' , @Array) <> 0</span><br /><br />                 <span style="color: rgb(0, 153, 0);">-- patindex matches the a pattern against a string<br /></span><span style="color: rgb(0, 153, 0);">                 </span><span style="color: rgb(51, 51, 255);">SELECT </span>@Separator_Position =  <span style="color: rgb(51, 51, 255);">PATINDEX</span>('%' + @Separator + '%' , @Array)<br />                 <span style="color: rgb(51, 51, 255);">SELECT </span>@Array_Value = <span style="color: rgb(51, 51, 255);">LEFT</span>(@Array, @Separator_Position - 1)<br /><br />                 <span style="color: rgb(0, 153, 0);">-- This is where you process the values passed.<br /></span><span style="color: rgb(0, 153, 0);">                 -- Replace this select statement with your processing<br /></span><span style="color: rgb(0, 153, 0);">                 -- @array_value holds the value of this element of the array</span><br /><br /><span style="color: rgb(0, 153, 0);">                 -- insert @array_value into the temp. table<br /></span>      <span style="color: rgb(51, 51, 255);">           IF LTRIM</span>(<span style="color: rgb(51, 51, 255);">RTRIM</span>(@Array_Value)) = '' <span style="color: rgb(51, 51, 255);">OR </span>@Array_Value = <span style="color: rgb(153, 153, 153);">NULL<br /></span>      <span style="color: rgb(51, 51, 255);">               BEGIN</span> <span style="color: rgb(0, 153, 0);">--  LTRIM(RTRIM(@Array_Value)) = '' OR @Array_Value = NULL<br /></span>                           <span style="color: rgb(51, 51, 255);">SET </span>@Temp = 1;<br />                     <span style="color: rgb(51, 51, 255);">END</span> <span style="color: rgb(0, 153, 0);">--  LTRIM(RTRIM(@Array_Value)) = '' OR @Array_Value = NULL<br /></span>                 <span style="color: rgb(51, 51, 255);">ELSE</span><span style="color: rgb(0, 153, 0);"><span style="color: rgb(51, 51, 255);"> </span>--  LTRIM(RTRIM(@Array_Value)) = '' OR @Array_Value = NULL<br /></span>                     <span style="color: rgb(51, 51, 255);">BEGIN </span><span style="color: rgb(0, 153, 0);">-- ELSE:  LTRIM(RTRIM(@Array_Value)) = '' OR @Array_Value = NULL<br /></span>                           <span style="color: rgb(51, 51, 255);">INSERT INTO </span>@Return (Word) <span style="color: rgb(51, 51, 255);">VALUES </span>(<span style="color: rgb(51, 51, 255);">LTRIM</span>(<span style="color: rgb(51, 51, 255);">RTRIM</span>(@Array_Value)));<br />                     <span style="color: rgb(51, 51, 255);">END </span><span style="color: rgb(0, 153, 0);">-- ELSE:  LTRIM(RTRIM(@Array_Value)) = '' OR @Array_Value = NULL</span><br /><br />      <span style="color: rgb(0, 153, 0);">           -- This replaces what we just processed with and empty string<br /></span>                 <span style="color: rgb(51, 51, 255);">SELECT </span>@Array = <span style="color: rgb(51, 51, 255);">STUFF</span>(@Array, 1, @Separator_Position, '');<br />           <span style="color: rgb(51, 51, 255);">END  </span><span style="color: rgb(0, 153, 0);">-- While PATINEDEX('%' + @Separator + '%' , @Array) <> 0</span><br /><br />      <span style="color: rgb(0, 153, 0);">-- return all rows from temp table<br /></span>      <span style="color: rgb(51, 51, 255);">RETURN</span>;<br /><br /><span style="color: rgb(51, 51, 255);">END </span><span style="color: rgb(0, 153, 0);">-- FUNCTION</span></span> </blockquote>