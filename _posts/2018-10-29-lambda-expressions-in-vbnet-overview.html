---
layout: post
title: Lambda Expressions in VB.Net, an Overview
date: '2018-10-29T19:00:00.000-05:00'
updated: "2019-03-07 19:46:00"
permalink: "/2018/10/lambda-expressions-in-vbnet-overview.html"
author: Stephen Wrighton
tags:
- Lambda
- VB.Net
- Coding
modified_time: '2018-10-29T19:00:06.524-05:00'
blogger_id: tag:blogger.com,1999:blog-947968907697915479.post-5995791876138781222
blogger_orig_url: https://programmer.wrighton.org/2018/10/lambda-expressions-in-vbnet-overview.html
---

<br /><div style="-en-clipboard: true;">I have to say, lambda expressions are awesome. &nbsp;</div><div><br /></div><div>To be explicit a lambda expression is an anonymous method that is used to create delegates or expression tree types. Additionally, they can be passed as arguments or returned as the result of a function &nbsp;Ideally, they should be short, highly explicit actions. &nbsp;Additionally, the convenience factor of lambda over traditional delegates is that they can be worked with without giving the method an explicit name and with the code immediately inline where it is to be used.</div><div><br /></div><div>I first stumbled across lambda expressions in relation to LINQ-to-SQL. &nbsp;I was wanting to perform some logic on my returned dataset, and all the documentation pointed that lambda expressions were the only way to accomplish what I was wanting. &nbsp;</div><div><br /></div><div>The bad part is that at the time, while VB.Net supported lambda expressions there were very little documentation in relation to them. To the point that I just failed to grok them, and ultimately, just used a user function in SQL Server do the work I needed, and went on. What was probably worse, is that Microsoft didn't really show examples of VB.Net lambda expressions for the longest time. &nbsp;Sure there was the explicit page for VB.Net lambda expressions, but all the sample codes, and the details on how to do the more arcane (and complicated) use cases &nbsp;were still in C#. &nbsp;Luckily, that's starting to change, but I still felt the need to build a more basic primer on them and their use in VB.Net.</div><div><br /></div><div>First is the base declaration syntax. &nbsp;As in standard methods, lambda expressions which return a result would use the FUNCTION declaration while ones which do not would use the SUB declaration.</div><div><br /></div><div>Now, in C# you would get a lambda expression built like this:</div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">n=&gt; n.IsReleased<br /></pre></div><br /> <div>In that, n is the input parameter, and the function returns the IsReleased property of the input. The same logic in VB.Net would be written as:</div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">Function</span> <span style="color: #FF0000; background-color: #FFAAAA">(</span><span style="color: #0066BB; font-weight: bold">movie</span>) movie.IsReleased<br /></pre></div><br /> <div>As is typically the case the VB.Net code is more verbose, but that verbosity also provides a level of clarity which the C# expression lacks. But despite the difference in verbosity, the syntax is strikingly similar. In the C# code, you start with the input parameter which goes into the logic statement.&nbsp; In the VB.Net&nbsp;code, you start with the function keyword, and its parameter goes into the logic statement.&nbsp; The difference is in the declaration of the actual method.&nbsp; In the C# you use the lambda operator, whereas in VB.Net&nbsp;you use the FUNCTION keyword.&nbsp;</div><div><br /></div><div>Another thing to consider is that lambda expressions are just a shorthand for anonymous methods.&nbsp; Anonymous methods are just those methods without a name, rather they're assigned to a variable of delegate type.&nbsp; In VB.Net an anonymous method would be written like:</div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">dim</span> IsMovieReleased <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">Function</span> <span style="color: #FF0000; background-color: #FFAAAA">(</span><span style="color: #0066BB; font-weight: bold">m</span> <span style="color: #000000; font-weight: bold">as</span> MovieObject) <span style="color: #000000; font-weight: bold">as</span> <span style="color: #333399; font-weight: bold">Boolean</span> <br />                                        <span style="color: #008800; font-weight: bold">Return</span> m.IsReleased <br />                                <span style="color: #008800; font-weight: bold">End</span> <span style="color: #008800; font-weight: bold">Function</span> <br /></pre></div><br /> <div>Now, when the logic extends to more than one line, then we need to use the Function/End Function syntax. For example:&nbsp;</div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%">Function(movie) <br />        Console.Log(<span style="color: #333399; font-weight: bold">String</span>.Format(<span style="background-color: #fff0f0">&quot;Checked Released State for {0}&quot;</span>, movie.Title))<br />        <span style="color: #008800; font-weight: bold">Return</span> movie.IsReleased <br /><span style="color: #008800; font-weight: bold">End</span> <span style="color: #008800; font-weight: bold">Function</span> <br /></pre></div><br /><div>And since the lambda expression is an anonymous function, it can be assigned to a delegate as well. </div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">Dim</span> isMovReleased <span style="color: #000000; font-weight: bold">As</span> Func(<span style="color: #008800; font-weight: bold">of</span> movie, <span style="color: #333399; font-weight: bold">Boolean</span>) <span style="color: #333333">=</span> Function(m) m.IsReleased <br /><span style="color: #008800; font-weight: bold">Dim</span> movieObject <span style="color: #000000; font-weight: bold">As</span> <span style="color: #008800; font-weight: bold">New</span> Movie <span style="color: #008800; font-weight: bold">With</span> {.IsReleased <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">True</span>, .Title<span style="color: #333333">=</span><span style="background-color: #fff0f0">&quot;Star Trek&quot;</span>}<br /><span style="color: #008800; font-weight: bold">Dim</span> isReleased <span style="color: #000000; font-weight: bold">As</span> <span style="color: #333399; font-weight: bold">Boolean</span> <span style="color: #333333">=</span> isMovReleased(movieObject)<br /></pre></div><br /> <div>Microsoft has produced a number of predefined anonymous delegates for our use. The FUNC delegate is for methods which return a value, while the ACTION delegate is for methods which don't. Each of them have a number of different possible parameters for a wide range of use cases.  </div><div><br /></div> <div>Now, the ACTION delegate is for assigning anonymous methods which doe not return a value.&nbsp;</div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">Dim</span> logMovie <span style="color: #000000; font-weight: bold">AS</span> Action(<span style="color: #008800; font-weight: bold">of</span> movie) <span style="color: #333333">=</span> Sub(m) Console.Log(m.Title) <br /><span style="color: #008800; font-weight: bold">Dim</span> movieObject <span style="color: #000000; font-weight: bold">As</span> <span style="color: #008800; font-weight: bold">New</span> Movie <span style="color: #008800; font-weight: bold">With</span> {.IsReleased <span style="color: #333333">=</span> <span style="color: #008800; font-weight: bold">True</span>, .Title<span style="color: #333333">=</span><span style="background-color: #fff0f0">&quot;Star Trek&quot;</span>}<br />logMovie(movieObject)<br /></pre></div><br /> <div>In VB.Net&nbsp;the primary difference in implementation for these two options would be the fact that one uses Sub/End Sub while the other uses Function/End Function.&nbsp;</div><div><br /></div><div>Now, as I stated earlier, I first stumbled across lambda expressions in relation to LINQ-to-SQL queries.&nbsp; What's happen is that the WHERE extension method for IEnumerable(of T) accepts the FUNC(of T, Boolean) delegate.&nbsp; This means that a method can be applied to the LINQ Queries applied against the datasource.&nbsp; Using the movie concept, and pulling the released movies, you would generate a LINQ-to-SQL statement like this:</div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">Dim</span> movieList <span style="color: #000000; font-weight: bold">as</span> List(<span style="color: #008800; font-weight: bold">of</span> Movies) <span style="color: #333333">=</span> dc.Movies. Where(Function(mv) mv.IsReleased).ToList()<br /></pre></div><br /><div>The final use of lambda expressions, and one that I don't typically use, is Expression trees.&nbsp; Expression trees are representations of code in a tree-like data structure where each of the nodes of the tree is a single atomic expression. Ideally an expression tree would be immutable once defined, and modifying any specific node would mean the creation of a new expression tree which the modifications are applied to, while leaving the existing tree(s) available to the system.</div><div><br /></div><div>Being able to compile and run the code represented by an expression tree means that the system can enable dynamic modification of executable code, LINQ executions against a database, as well as create dynamic queries.&nbsp;&nbsp;</div><div><br /></div><div>Now, imagine this lambda expression:</div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">Dim</span> deleg <span style="color: #000000; font-weight: bold">As</span> Func(<span style="color: #008800; font-weight: bold">of</span> <span style="color: #333399; font-weight: bold">Integer</span>, <span style="color: #333399; font-weight: bold">Boolean</span>)<br />deleg <span style="color: #333333">=</span> Function(f)  <span style="color: #0000DD; font-weight: bold">0</span> <span style="color: #333333">&lt;</span> f <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">15</span> <br /></pre></div><br /><div>It's purpose is to determine if the passed in parameter&nbsp; is between 1 and 15.&nbsp; But it can be built as an Expression Tree in this manner:</div><!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span style="color: #008800; font-weight: bold">Dim</span> expr <span style="color: #000000; font-weight: bold">as</span> System.Linq.Expressions.Expression(<span style="color: #008800; font-weight: bold">of</span> Func)<br />expr <span style="color: #333333">=</span> Function(f) <span style="color: #0000DD; font-weight: bold">0</span> <span style="color: #333333">&lt;</span> f <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">15</span> <br /><span style="color: #008800; font-weight: bold">Dim</span> deleg <span style="color: #000000; font-weight: bold">As</span> Func(<span style="color: #008800; font-weight: bold">of</span> <span style="color: #333399; font-weight: bold">Integer</span>, <span style="color: #333399; font-weight: bold">Boolean</span>)<br />deleg <span style="color: #333333">=</span> expr.Compile() <br /></pre></div><br /> <div>Lambda expressions are one of the better adds to VB.Net&nbsp;over the years, and can lead to a lot of making the code clearer and helping tighten the code significantly.&nbsp; An aspect that makes code easier to maintain as well as more readable, at least one the initial hurdle of understanding the explicit needs for declaration and use are groked.&nbsp; And frankly, anything that helps bring clarity, conciseness, maintainability and readability to code is a good thing in my book.&nbsp;</div><br />