---
layout: post
title: Row Not Found...
date: '2011-08-18T20:33:00.000-05:00'
updated: "2019-03-07 19:46:00"
permalink: "/2011/08/row-not-found.html"
author: Stephen Wrighton
tags:
- LINQ-to-SQL
- ".NET"
- programming
- SQL Server
- LINQ
modified_time: '2011-08-19T08:34:56.737-05:00'
blogger_id: tag:blogger.com,1999:blog-947968907697915479.post-569795071768610390
blogger_orig_url: https://programmer.wrighton.org/2011/08/row-not-found.html
---

We (as in the company I work for) have a product which we've named Bounce. Bounce is, as one might guess from the name, a product which reboots servers. It's a solution-in-a-box type thing, that comes in a 1u chassis for server racks. <br /><br />This product is actual in production at a number of sites, including ours. Additionally, our site is the most complex of the various configurations out there, just because we have a couple of different production networks, our corporate networks, and a "development" network where those servers that use developers torture reside.<br /><br />Regardless, there was a bug in Bounce, where it would randomly report a failure in one of the servers. Well, this little bug had been bothering the Network guys for a bit, and they finally brought it to my attention as well as the boss' attention--which resulted in some time scheduled to work on the issues, as well as add a few additional enhancements that had been hanging out on the drawing board for a while.<br /><br />So, I started work, and tested the bounce group that the issue usually popped up in, and found, absolutely nothing.&nbsp; Everything worked perfectly.<br /><br />So, I chalked it up to gremlins, and implemented the system additions.<br /><br />Well, I was doing some final system tests, when, lo and behold, the issue cropped up. I opened up the event log, and saw it somewhat flooded with the same message over, and over again, the only difference between those messages were the fact that it was being generated for every server configured in the system.<br /><br />That error message read: <i><b>r</b><b>ow could not be found or updated.</b></i><br /><br />Talk about useful.<br /><br />So, I went to Google, and found some discussions that blamed one of two things:<br /><ol><li>Concurrency issues generated by the "no count" flag being set on the SQL Server's default connection options</li><li>A difference between the DBML definition of the table, and the actual underlying table</li></ol>So, I checked both issues. I mean it's only a matter of moments to open up SQL Management Studio and ensure that no count wasn't checked, and only a bit harder to just flat out delete all the tables and views on the DBML and re-drag them into the designer.&nbsp; Sadly, neither solution worked.<br /><br />Since I was certain that the DBML looked just like the underlying tables (having just dragged them over) I looked more closely into the concurrency issues that folks are reporting.<br /><br />And I realized that this isn't a SQL concurrency issue, basically, it's not a race condition where two requests are both trying to modify the table at the same time.&nbsp; This is one of those other definitions for the word concurrency, specifically things being in accordance or agreement.<br /><br />The below is basically what was happening:<br /><blockquote>Get List of Devices in BOUNCE QUEUE For Each Device in List<br /><blockquote>get ComputerDetails as LINQ object<br />Perform Bounce<br /><b>Perform System Checks Function on ComputerObject</b><br />Update properties of ComputerDetails<br />Submit Changes on the DBML</blockquote>Next </blockquote>What is important is the bolded line there.&nbsp; That Perform System Checks Function was updating the COMPUTER DETAILS table via an EXECUTECOMMAND call on the DBML object.&nbsp;<br /><br />Basically, it was modifying the underlying data table, without updating the CompterDetails LINQ object.<br /><br />This was fine until I actually updated the ComputerDetails LINQ object and then submitted it back to the database.&nbsp; When I did that, the system performed a concurrency check (in the "in agreement" definition) against the actual row using those properties that were not being updated.&nbsp; Since they had been modified elsewhere, outside of the normal LINQ-to-SQL paradigm, LINQ was unable to find the row--or at least upon finding it decided that "no, this wasn't really the row I was looking for."<br /><br />This means, that it happily spat out a "Row not found" error.<br /><br />I immediately thought up two possible solutions for what was happening, the first was to re-work the code to use the LINQ object in all those places where in-line SQL was being used.&nbsp; The second was to re-work the one place I was submitting the LINQ object to use in-line SQL.&nbsp;&nbsp; Being a lazy programmer, I happily took the latter option.<br /><br />Lo an behold, my event logs are clean, the error has stopped presenting itself and all is happy and right with the world.&nbsp; At least until the next bug. 