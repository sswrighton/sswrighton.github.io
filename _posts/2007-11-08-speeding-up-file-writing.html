---
layout: post
title: Speeding up File Writing
date: '2007-11-08T11:57:00.000-06:00'
updated: "2019-03-07 19:46:00"
permalink: "/2007/11/speeding-up-file-writing.html"
author: Stephen Wrighton
tags:
- ".NET"
- programming
- VB.Net
- strings
modified_time: '2007-11-08T12:01:57.175-06:00'
blogger_id: tag:blogger.com,1999:blog-947968907697915479.post-3699701532226368312
blogger_orig_url: https://programmer.wrighton.org/2007/11/speeding-up-file-writing.html
---

I'm dealing with rather large data sets these days. I'm talking on the order of a few million records easy.  One of the tasks I've been given is to take these records and generate a flat file of them to transfer to another process for external processing.<br /><br />Not a problem, right?  In fact it could be done just from the Query Analyzer with its ability to save results to a file.<br /><br />Well, sometimes that works all right, but this is a process that needs to be run routinely, plus at random other times of the year. So I shoved it into a simple console application where I have a configuration file, and I can override those configuration options via command line arguments.<br /><br />It worked beautifully for my first few test sets of data I ran through it, the largest being about 5,000 records.  Then I pulled the full test data set, which has about a million records. After staring at that black screen for what felt like forever, I went about hunting a way to speed things up.<br /><br />My studies uncovered the fact that IO.Stream classes were faster than Microsoft.VisualBasic.FilePut classes. The problem there was that I was already using the IO.Stream classes.<br /><br />So, I stumbled through things, hunting for ways to improve my efficiency.  I tried IO.File.CreateText as a way to return a StreamWriter, but that had no discernable efficiency bonuses (added an extra 300-400 milliseconds at 1,000 records).<br /><br />I tried using a StringBuilder instance to build the file and then shoved it into the StreamWriter all at one time (as opposed to writing directly to the file every line the way I had been doing).  Oddly, that still had no discernable efficiency bonuses (added an extra 100-200 milliseconds at 1,000 records).<br /><br />Almost ready to give up, I went looking through the IO.File class to see what functions I could use. Which is when I stumbled upon IO.File.AppendText. Giving an internal shrug, I set about reworking my function to use a StringBuilder class and the AppendText file.<br /><br />As an aside, note that if the file exists, I always delete it so that I'm creating a new file every time.<br /><br />Imagine my surprise when I saw a rather marked difference in efficiency, as evidenced by a two-second drop in speed. Not quite sure what to make of it, I ran the tests again, and then increased my records to 5,000 and then to 100,000.<br /><br />I was flabbergasted at these results:<br /><span style="font-weight: bold;">1,000 Records </span><br /><blockquote>Method 1:<br />1.    0:0:16:47<br />2.    0:0:14:344<br />3.    0:0:14:406<br /><br />Method 2:<br />1.    0:0:12:687<br />2.    0:0:12:78<br />3.    0:0:12:343</blockquote><span style="font-weight: bold;">5,000 Records</span><br /><blockquote>Method 1:<br />1.    0:0:25:0<br />2.    0:0:24:686<br />3.    0:0:24:702<br /><br />Method 2:<br />1.    0:0:12:280<br />2.    0:0:12:124<br />3.    0:0:12:265</blockquote><span style="font-weight: bold;">100,000 Records</span><br /><blockquote>Method 1:<br />1.    0:4:23:249<br />2.    0:4:25:798<br />3.    0:4:25:675</blockquote><blockquote></blockquote><blockquote>Method 2:<br />1.    0:0:18:952<br />2.    0:0:21:77<br />3.    0:0:20:983</blockquote>I couldn't believe it. The AppendText function working with a StringBuilder class was nearly 4 minutes faster than writing the file directly. Sure, it means I have to touch the data an extra time, but with that as a speed increase, that is something I'm quite willing to live with.